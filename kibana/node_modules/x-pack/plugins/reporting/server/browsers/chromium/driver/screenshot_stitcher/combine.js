"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// No types found for this package. May want to investigate an alternative with types.
// @ts-ignore: implicit any for JS file
const stream_to_observable_1 = __importDefault(require("@samverschueren/stream-to-observable"));
const pngjs_1 = require("pngjs");
const Rx = __importStar(require("rxjs"));
const operators_1 = require("rxjs/operators");
class CapturePngSizeError extends Error {
    constructor(actualSize, expectedSize) {
        super();
        this.message =
            `Capture PNG size error. Please visit https://github.com/elastic/kibana/issues/19563 to report this error. ` +
                `Screenshot captured of size ${actualSize.width}x${actualSize.height} was not of expected size ${expectedSize.width}x${expectedSize.height}`;
    }
}
exports.CapturePngSizeError = CapturePngSizeError;
// if we're only given one screenshot, and it matches the given size
// we're going to skip the combination and just use it
const canUseFirstScreenshot = (screenshots, size) => {
    if (screenshots.length !== 1) {
        return false;
    }
    const firstScreenshot = screenshots[0];
    return (firstScreenshot.rectangle.width === size.width &&
        firstScreenshot.rectangle.height === size.height);
};
/**
 * Combines the screenshot clips into a single screenshot of size `outputSize`.
 * @param screenshots - Array of screenshots to combine
 * @param outputSize - Final output size that the screenshots should match up with
 * @param logger - logger for extra debug output
 */
function $combine(screenshots, outputSize, logger) {
    logger.debug(`Combining screenshot clips into final, scaled output dimension of ${JSON.stringify(outputSize)}`);
    if (screenshots.length === 0) {
        return Rx.throwError('Unable to combine 0 screenshots');
    }
    if (canUseFirstScreenshot(screenshots, outputSize)) {
        return Rx.of(screenshots[0].data);
    }
    // Turn the screenshot data into actual PNGs
    const pngs$ = Rx.from(screenshots).pipe(operators_1.mergeMap((screenshot) => {
        const png = new pngjs_1.PNG();
        const buffer = Buffer.from(screenshot.data, 'base64');
        const parseAsObservable = Rx.bindNodeCallback(png.parse.bind(png));
        return parseAsObservable(buffer);
    }, (screenshot, png) => {
        if (png.width !== screenshot.rectangle.width ||
            png.height !== screenshot.rectangle.height) {
            const error = new CapturePngSizeError(png, screenshot.rectangle);
            logger.error(error.message);
            throw error;
        }
        return { screenshot, png };
    }));
    const output$ = pngs$.pipe(operators_1.reduce((output, input) => {
        const { png, screenshot } = input;
        // Spitting out a lot of output to help debug https://github.com/elastic/kibana/issues/19563. Once that is
        // fixed, this should probably get pared down.
        logger.debug(`Output dimensions is ${JSON.stringify(outputSize)}`);
        logger.debug(`Input png w: ${png.width} and h: ${png.height}`);
        logger.debug(`Creating output png with ${JSON.stringify(screenshot.rectangle)}`);
        const { rectangle } = screenshot;
        png.bitblt(output, 0, 0, rectangle.width, rectangle.height, rectangle.x, rectangle.y);
        return output;
    }, new pngjs_1.PNG({ width: outputSize.width, height: outputSize.height })));
    return output$.pipe(operators_1.tap(png => png.pack()), operators_1.switchMap(stream_to_observable_1.default), operators_1.toArray(), operators_1.map((chunks) => Buffer.concat(chunks).toString('base64')));
}
exports.$combine = $combine;
